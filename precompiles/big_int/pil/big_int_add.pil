require "std_lookup.pil"
require "std_range_check.pil"

/// BinIntAdd Precompile
///
/// Proves the addition of n-bits, using N_RC chunks of RC chunks of 32 bits
/// RC is the number of chunks of 32 bits defined in native architecture
/// N_RC is the number of chunks of these values. 
/// 
/// Parameters:
///
/// - N: number of rows by instance
/// - operation_bus_id: the opid of bus used by precompile
/// - bits: number of bits of the addition (N_RC * RC * 32)
/// - RC: number of chunks of 32 bits defined in native architecture
/// - operation_code: the operation code used to identify the precompile
///
/// Integration:
///
/// - main assumes an operation on operation_bus_id:
///   [ operation_code, a: [step, 0], b: [addr_params, 0], c: [carry_out, 0], flag: carry_out ]
///
/// - precompiles "load" params from memory:
///     addr_params -> addr_a
///     addr_params + 8 -> addr_b
///     addr_params + 16 -> cin
///     addr_params + 24 -> addr_c
///     addr_a -> a[0] (a[0][1], a[0][1])
///     addr_a + 8 -> a[0] (a[0][1], a[0][1])
///     :
///     addr_a + 8 * (N_RC - 1) -> a[N_RC-1] (a[N_RC-1][1], a[N_RC-1][1])
///     addr_b -> b[0] (b[0][1], b[0][1])
///     addr_b + 8 -> b[0] (b[0][1], b[0][1])
///     :
///     addr_b + 8 * (N_RC - 1) -> b[N_RC-1] (b[N_RC-1][1], b[N_RC-1][1])
//
/// - precompiles "store" result to memory:
///     addr_c <- c[0] (c_chunks[0][0] + c_chunks[0][1] << 16, 
///                     c_chunks[0][2] + c_chunks[0][3] << 16)
///     addr_c + 8 <- c[1] (c_chunks[1][0] + c_chunks[1][1] << 16, 
///                         c_chunks[1][2] + c_chunks[1][3] << 16)
///     :
///     addr_c + 8 * (N_RC - 1) <- c[N_RC-1] (c_chunks[N_RC-1][0] + c_chunks[N_RC-1][1] << 16, 
///                                           c_chunks[N_RC-1][2] + c_chunks[N_RC-1][3] << 16)

airtemplate BigIntAdd(const int N = 2**21, const int operation_bus_id = OPERATION_BUS_ID, 
                      const int bits = 256, 
                      const int operation_code) {
                        
    const int RC = 2; 
    const int N_RC = bits / (RC * 32);
    assert_eq(N_RC * RC * 32, bits);

    col witness bits(32) a[N_RC][RC];
    col witness bits(32) b[N_RC][RC];
    col witness bits(16) c_chunks[N_RC][RC*2];
    col witness bits(1) cout[N_RC][RC];

    // address of struct with params
    col witness bits(32) addr_params;

    // address of a chunks
    col witness bits(32) addr_a;

    // address of b chunks
    col witness bits(32) addr_b;

    // address of c chunks
    col witness bits(32) addr_c;

    // main step of the operation
    col witness bits(40) step;

    // carry in binary column
    col witness bits(1) cin;

    // selector for enable row
    col witness bits(1) sel;

    const expr c[N_RC][RC];

    sel * (1 - sel) === 0;
    cin * (1 - cin) === 0;

    // operate for each group of 64-bits (2 chunks of 32-bits)
    for (int k = 0; k < N_RC; k++) {
        // iterate over each 32-bit chunk
        for (int i = 0; i < RC; i++) {
            // binary constraint for carry out
            cout[k][i] * (1 - cout[k][i]) === 0;

            // prepare left part of the addition, the first chunk takes cin as carry in, and the rest
            // takes thre previous carry out
            expr left = a[k][i] + b[k][i];

            if (i > 0) {
                // add the previous carry ou
                left = left + cout[k][i-1];
            } else if (k > 0) {
                // add the last carry out of the previous group
                left = left + cout[k-1][RC-1];
            } else {
                left = left + cin;
            }
            // the addition and the proposal result must match
            left === cout[k][i] * 2 ** 32 + c_chunks[k][i * 2 + 1] * 2 ** 16 + c_chunks[k][i * 2];

            // define C as the shifted sum of chunks
            c[k][i] = c_chunks[k][i * 2 + 1] * 2 ** 16 + c_chunks[k][i * 2];

            // for each chunk, must be verified that it's correct 16-bit value
            range_check(expression: c_chunks[k][i * 2], min: 0, max: 2**16 - 1, sel: sel);
            range_check(expression: c_chunks[k][i * 2 + 1], min: 0, max: 2**16 - 1, sel: sel);
        }
        
        // for each chunk of a,b read from memory (addr_a, addr_b)
        precompiled_mem_load(addr: addr_a + k * 8, main_step: step, value: a[k], sel: sel);
        precompiled_mem_load(addr: addr_b + k * 8, main_step: step, value: b[k], sel: sel);

        // for each chunk of c write to memory (addr_c)
        precompiled_mem_store(addr: addr_c + k * 8, main_step: step, value: c[k], sel: sel);
    }

    // load parameters from struct
    // load addr_a from addr_params[0]
    precompiled_mem_load(addr: addr_params, main_step: step, value: [addr_a, 0], sel: sel);
    // load addr_b from addr_params[1]
    precompiled_mem_load(addr: addr_params + 8, main_step: step, value: [addr_b, 0], sel: sel);
    // load cin from addr_params[2]
    precompiled_mem_load(addr: addr_params + 16, main_step: step, value: [cin, 0], sel: sel);
    // load addr_c from addr_params[3]
    precompiled_mem_load(addr: addr_params + 24, main_step: step, value: [addr_c, 0], sel: sel);

    const expr final_cout = cout[N_RC-1][RC-1];

    // proves the operation lauched by main, c = flag = carry_out
    lookup_proves(operation_bus_id, [operation_code, step, 0, addr_params, 0, final_cout, 0, final_cout], sel);
}